#!/usr/bin/env python3
"""Apply Capacity Policy Threshold Patch command utility.

This script is part of the writing-agent operational toolchain.
"""

from __future__ import annotations

import argparse
import hashlib
import json
import time
from pathlib import Path
from typing import Any


def _load_json(path: Path) -> dict[str, Any] | None:
    if not path.exists():
        return None
    try:
        raw = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return None
    return raw if isinstance(raw, dict) else None


def _safe_float(value: Any, default: float = 0.0) -> float:
    try:
        return float(value)
    except Exception:
        return float(default)


def _safe_int(value: Any, default: int = 0) -> int:
    try:
        return int(value)
    except Exception:
        return int(default)


def _normalize_text(value: Any) -> str:
    return str(value or "").strip()


def _normalize_profile(value: Any) -> str:
    text = _normalize_text(value).lower()
    alias = {
        "production": "prod",
        "stage": "staging",
        "development": "dev",
    }
    return alias.get(text, text)


def _stable_json_sha256(payload: dict[str, Any] | None) -> str:
    if not isinstance(payload, dict):
        return ""
    try:
        text = json.dumps(payload, ensure_ascii=False, sort_keys=True, separators=(",", ":"))
    except Exception:
        return ""
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def _check_row(*, check_id: str, ok: bool, value: Any, expect: str, mode: str = "enforce") -> dict[str, Any]:
    return {
        "id": str(check_id),
        "ok": bool(ok),
        "value": value,
        "expect": str(expect),
        "mode": str(mode or "enforce"),
    }


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Apply capacity policy patch generated by scripts/capacity_alert_policy_drift.py."
    )
    parser.add_argument("--patch", default=".data/out/capacity_policy_threshold_patch_suggested.json")
    parser.add_argument("--policy", default="")
    parser.add_argument("--capacity-profile", default="")
    parser.add_argument("--max-exceeded-metrics", type=int, default=0)
    parser.add_argument("--min-confidence", type=float, default=0.45)
    parser.add_argument("--allow-relax", action="store_true")
    parser.add_argument("--ignore-source-hash", action="store_true")
    parser.add_argument("--reason", default="")
    parser.add_argument("--dry-run", action="store_true")
    parser.add_argument("--strict", action="store_true")
    parser.add_argument("--out", default="")
    args = parser.parse_args()

    started = time.time()
    checks: list[dict[str, Any]] = []
    gate_mode = "enforce" if bool(args.strict) else "warn"

    patch_path = Path(str(args.patch))
    patch_raw = _load_json(patch_path)
    checks.append(
        _check_row(
            check_id="patch_loaded",
            ok=isinstance(patch_raw, dict),
            value=patch_path.as_posix(),
            expect="patch file exists and valid json",
        )
    )
    if not isinstance(patch_raw, dict):
        report = {
            "ok": False,
            "started_at": round(started, 3),
            "ended_at": round(time.time(), 3),
            "duration_s": round(time.time() - started, 3),
            "checks": checks,
        }
        out_default = Path(".data/out") / f"capacity_policy_patch_apply_{int(time.time())}.json"
        out_path = Path(str(args.out or out_default))
        out_path.parent.mkdir(parents=True, exist_ok=True)
        out_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
        print(json.dumps(report, ensure_ascii=False, indent=2))
        return 2

    patch_policy_path = str(patch_raw.get("policy_path") or "").strip()
    patch_capacity_profile = _normalize_profile(patch_raw.get("capacity_profile"))
    requested_capacity_profile = _normalize_profile(args.capacity_profile)
    policy_path = Path(str(args.policy).strip()) if str(args.policy).strip() else Path(patch_policy_path or "security/capacity_policy.json")
    policy_raw = _load_json(policy_path)
    checks.append(
        _check_row(
            check_id="policy_loaded",
            ok=isinstance(policy_raw, dict),
            value=policy_path.as_posix(),
            expect="target capacity policy exists and valid",
        )
    )

    candidate_policy = patch_raw.get("candidate_policy")
    checks.append(
        _check_row(
            check_id="candidate_policy_available",
            ok=isinstance(candidate_policy, dict),
            value=isinstance(candidate_policy, dict),
            expect="patch contains candidate_policy object",
        )
    )
    checks.append(
        _check_row(
            check_id="capacity_profile_match",
            ok=(not requested_capacity_profile) or (not patch_capacity_profile) or (requested_capacity_profile == patch_capacity_profile),
            value={
                "requested_capacity_profile": requested_capacity_profile,
                "patch_capacity_profile": patch_capacity_profile,
            },
            expect="requested capacity profile matches patch profile when both are provided",
            mode=gate_mode,
        )
    )

    source_policy_sha = str(patch_raw.get("source_policy_sha256") or "").strip()
    live_policy_sha = _stable_json_sha256(policy_raw if isinstance(policy_raw, dict) else None)
    hash_ok = bool(args.ignore_source_hash) or (not source_policy_sha) or (source_policy_sha == live_policy_sha)
    checks.append(
        _check_row(
            check_id="source_policy_hash_match",
            ok=hash_ok,
            value={
                "patch_source_policy_sha256": source_policy_sha,
                "live_policy_sha256": live_policy_sha,
                "ignore_source_hash": bool(args.ignore_source_hash),
            },
            expect="patch source hash should match live policy",
            mode=gate_mode,
        )
    )

    summary = patch_raw.get("summary") if isinstance(patch_raw.get("summary"), dict) else {}
    exceeded_metrics = _safe_int(summary.get("exceeded_metrics"), 0)
    max_exceeded = max(0, int(args.max_exceeded_metrics))
    checks.append(
        _check_row(
            check_id="exceeded_metrics_gate",
            ok=exceeded_metrics <= max_exceeded,
            value={"exceeded_metrics": exceeded_metrics, "max_allowed": max_exceeded},
            expect="exceeded_metrics <= max_exceeded_metrics",
            mode=gate_mode,
        )
    )

    confidence = _safe_float(summary.get("confidence"), _safe_float(patch_raw.get("confidence"), -1.0))
    min_confidence = float(args.min_confidence)
    confidence_ok = confidence < 0.0 or confidence >= min_confidence
    checks.append(
        _check_row(
            check_id="confidence_gate",
            ok=confidence_ok,
            value={"confidence": round(confidence, 4) if confidence >= 0 else confidence, "min_confidence": min_confidence},
            expect="confidence is high enough or omitted",
            mode=gate_mode,
        )
    )

    changes = patch_raw.get("changes") if isinstance(patch_raw.get("changes"), list) else []
    relax_metrics = [
        str(row.get("metric") or "")
        for row in changes
        if isinstance(row, dict) and str(row.get("direction") or "") == "relax" and bool(row.get("has_values"))
    ]
    checks.append(
        _check_row(
            check_id="relax_changes_gate",
            ok=bool(args.allow_relax) or len(relax_metrics) == 0,
            value={"allow_relax": bool(args.allow_relax), "relax_metrics": relax_metrics},
            expect="no relax changes unless allow_relax=true",
            mode=gate_mode,
        )
    )

    reason = str(args.reason or "").strip()
    checks.append(
        _check_row(
            check_id="reason_required",
            ok=bool(reason),
            value=reason,
            expect="non-empty reason for patch apply traceability",
        )
    )

    enforce_rows = [row for row in checks if str(row.get("mode") or "enforce") == "enforce"]
    ok = all(bool(row.get("ok")) for row in enforce_rows)

    backup_path: Path | None = None
    applied = False
    if ok and isinstance(policy_raw, dict) and isinstance(candidate_policy, dict):
        merged = json.loads(json.dumps(candidate_policy))
        node = merged.get("citation_metrics") if isinstance(merged.get("citation_metrics"), dict) else {}
        meta = node.get("threshold_patch_meta") if isinstance(node.get("threshold_patch_meta"), dict) else {}
        meta.update(
            {
                "updated_at": round(time.time(), 3),
                "updated_by": "scripts/apply_capacity_policy_threshold_patch.py",
                "patch_path": patch_path.as_posix(),
                "source_policy_sha256": source_policy_sha,
                "live_policy_sha256_before_apply": live_policy_sha,
                "reason": reason,
                "allow_relax": bool(args.allow_relax),
                "dry_run": bool(args.dry_run),
                "capacity_profile": requested_capacity_profile or patch_capacity_profile,
            }
        )
        node["threshold_patch_meta"] = meta
        merged["citation_metrics"] = node

        if not bool(args.dry_run):
            backup_path = Path(".data/out") / f"capacity_policy_backup_{int(time.time())}.json"
            backup_path.parent.mkdir(parents=True, exist_ok=True)
            backup_path.write_text(json.dumps(policy_raw, ensure_ascii=False, indent=2), encoding="utf-8")
            policy_path.parent.mkdir(parents=True, exist_ok=True)
            policy_path.write_text(json.dumps(merged, ensure_ascii=False, indent=2), encoding="utf-8")
            applied = True

    ended = time.time()
    report = {
        "ok": bool(ok),
        "started_at": round(started, 3),
        "ended_at": round(ended, 3),
        "duration_s": round(ended - started, 3),
        "strict": bool(args.strict),
        "patch_path": patch_path.as_posix(),
        "policy_path": policy_path.as_posix(),
        "dry_run": bool(args.dry_run),
        "applied": bool(applied),
        "backup_path": backup_path.as_posix() if isinstance(backup_path, Path) else "",
        "reason": reason,
        "checks": checks,
    }

    out_default = Path(".data/out") / f"capacity_policy_patch_apply_{int(ended)}.json"
    out_path = Path(str(args.out or out_default))
    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(json.dumps(report, ensure_ascii=False, indent=2), encoding="utf-8")
    print(json.dumps(report, ensure_ascii=False, indent=2))
    if bool(args.strict):
        return 0 if bool(ok) else 2
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
